<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/lk/sampath/leaderboard/client/SonarQubeClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/lk/sampath/leaderboard/client/SonarQubeClient.java" />
              <option name="originalContent" value="package lk.sampath.leaderboard.client;&#10;&#10;import lk.sampath.leaderboard.config.SonarQubeProperties;&#10;import lk.sampath.leaderboard.dto.*;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.boot.web.client.RestTemplateBuilder;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.client.RestTemplate;&#10;import org.springframework.web.client.HttpClientErrorException;&#10;import org.springframework.web.util.UriComponentsBuilder;&#10;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class SonarQubeClient {&#10;&#10;    private final SonarQubeProperties properties;&#10;    private final RestTemplateBuilder restTemplateBuilder;&#10;&#10;    private RestTemplate restTemplate() {&#10;        // Use RestTemplateBuilder's basicAuthentication so preemptive auth is configured when supported&#10;        // If token is present, configure builder with token as username and empty password; otherwise builder stays default&#10;        if (properties.getToken() != null &amp;&amp; !properties.getToken().isBlank()) {&#10;            return restTemplateBuilder.basicAuthentication(properties.getToken(), &quot;&quot;).build();&#10;        }&#10;        if (properties.getUsername() != null &amp;&amp; !properties.getUsername().isBlank()) {&#10;            return restTemplateBuilder.basicAuthentication(properties.getUsername(), properties.getPassword() == null ? &quot;&quot; : properties.getPassword()).build();&#10;        }&#10;        return restTemplateBuilder.build();&#10;    }&#10;&#10;    public List&lt;SonarProjectSearchResponse.Component&gt; fetchAllProjects() {&#10;        List&lt;SonarProjectSearchResponse.Component&gt; allProjects = new ArrayList&lt;&gt;();&#10;        int page = 1;&#10;&#10;        while (page &lt;= properties.getMaxPages()) {&#10;            String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                    .path(&quot;/api/components/search&quot;)&#10;                    .queryParam(&quot;qualifiers&quot;, &quot;TRK&quot;)&#10;                    .queryParam(&quot;p&quot;, page)&#10;                    .queryParam(&quot;ps&quot;, properties.getPageSize())&#10;                    .toUriString();&#10;&#10;            try {&#10;                ResponseEntity&lt;SonarProjectSearchResponse&gt; response = restTemplate().exchange(&#10;                        url, HttpMethod.GET, createHttpEntity(), SonarProjectSearchResponse.class);&#10;&#10;                if (response.getBody() != null) {&#10;                    List&lt;SonarProjectSearchResponse.Component&gt; components = response.getBody().getComponents();&#10;                    if (components.isEmpty()) {&#10;                        break;&#10;                    }&#10;                    allProjects.addAll(components);&#10;&#10;                    if (components.size() &lt; properties.getPageSize()) {&#10;                        break;&#10;                    }&#10;                }&#10;                page++;&#10;            } catch (Exception e) {&#10;                logRequestError(e, &quot;Error fetching projects at page &quot; + page);&#10;                break;&#10;            }&#10;        }&#10;&#10;        log.info(&quot;Fetched {} projects from SonarQube&quot;, allProjects.size());&#10;        return allProjects;&#10;    }&#10;&#10;    public List&lt;SonarIssuesSearchResponse.IssueDetail&gt; fetchIssuesForProject(String projectKey, LocalDate fromDate, LocalDate toDate) {&#10;        List&lt;SonarIssuesSearchResponse.IssueDetail&gt; allIssues = new ArrayList&lt;&gt;();&#10;        int page = 1;&#10;&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;&#10;        while (page &lt;= properties.getMaxPages()) {&#10;            String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                    .path(&quot;/api/issues/search&quot;)&#10;                    .queryParam(&quot;componentKeys&quot;, projectKey)&#10;                    .queryParam(&quot;createdAfter&quot;, fromDate.format(formatter))&#10;                    .queryParam(&quot;createdBefore&quot;, toDate.format(formatter))&#10;                    .queryParam(&quot;p&quot;, page)&#10;                    .queryParam(&quot;ps&quot;, properties.getPageSize())&#10;                    .queryParam(&quot;additionalFields&quot;, &quot;comments&quot;)&#10;                    .toUriString();&#10;&#10;            try {&#10;                ResponseEntity&lt;SonarIssuesSearchResponse&gt; response = restTemplate().exchange(&#10;                        url, HttpMethod.GET, createHttpEntity(), SonarIssuesSearchResponse.class);&#10;&#10;                if (response.getBody() != null) {&#10;                    List&lt;SonarIssuesSearchResponse.IssueDetail&gt; issues = response.getBody().getIssues();&#10;                    if (issues.isEmpty()) {&#10;                        break;&#10;                    }&#10;                    allIssues.addAll(issues);&#10;&#10;                    if (issues.size() &lt; properties.getPageSize()) {&#10;                        break;&#10;                    }&#10;                }&#10;                page++;&#10;            } catch (Exception e) {&#10;                logRequestError(e, &quot;Error fetching issues for project &quot; + projectKey + &quot; at page &quot; + page);&#10;                break;&#10;            }&#10;        }&#10;&#10;        log.info(&quot;Fetched {} issues for project {}&quot;, allIssues.size(), projectKey);&#10;        return allIssues;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; fetchProjectMetrics(String projectKey) {&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/measures/component&quot;)&#10;                .queryParam(&quot;component&quot;, projectKey)&#10;                .queryParam(&quot;metricKeys&quot;, &quot;ncloc,bugs,vulnerabilities,code_smells&quot;)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarMeasuresResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarMeasuresResponse.class);&#10;&#10;            Map&lt;String, String&gt; metrics = new HashMap&lt;&gt;();&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getComponent() != null) {&#10;                response.getBody().getComponent().getMeasures().forEach(measure -&gt;&#10;                        metrics.put(measure.getMetric(), measure.getValue())&#10;                );&#10;            }&#10;            return metrics;&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching metrics for project &quot; + projectKey);&#10;            return Collections.emptyMap();&#10;        }&#10;    }&#10;&#10;    public Set&lt;String&gt; fetchAuthorsForProject(String projectKey) {&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/issues/authors&quot;)&#10;                .queryParam(&quot;project&quot;, projectKey)&#10;                .queryParam(&quot;ps&quot;, 500)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarAuthorsResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarAuthorsResponse.class);&#10;&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getAuthors() != null) {&#10;                return new HashSet&lt;&gt;(response.getBody().getAuthors());&#10;            }&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching authors for project &quot; + projectKey);&#10;        }&#10;        return Collections.emptySet();&#10;    }&#10;&#10;    /**&#10;     * Fetch user details (display name) from SonarQube for a given login/author key.&#10;     * Uses /api/users/search?login={login}&#10;     */&#10;    public Optional&lt;String&gt; fetchUserDisplayName(String login) {&#10;        if (login == null || login.isBlank()) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/users/search&quot;)&#10;                .queryParam(&quot;login&quot;, login)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarUserSearchResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarUserSearchResponse.class);&#10;&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getUsers() != null &amp;&amp; !response.getBody().getUsers().isEmpty()) {&#10;                SonarUserSearchResponse.User user = response.getBody().getUsers().get(0);&#10;                if (user.getName() != null &amp;&amp; !user.getName().isBlank()) {&#10;                    return Optional.of(user.getName());&#10;                }&#10;                if (user.getLogin() != null &amp;&amp; !user.getLogin().isBlank()) {&#10;                    return Optional.of(user.getLogin());&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching user details for login &quot; + login);&#10;        }&#10;        return Optional.empty();&#10;    }&#10;&#10;    private HttpEntity&lt;?&gt; createHttpEntity() {&#10;        HttpHeaders headers = new HttpHeaders();&#10;        // Prefer API token; if not present, fall back to username/password&#10;        if (properties.getToken() != null &amp;&amp; !properties.getToken().isBlank()) {&#10;            headers.setBasicAuth(properties.getToken(), &quot;&quot;);&#10;        } else if (properties.getUsername() != null &amp;&amp; !properties.getUsername().isBlank()) {&#10;            headers.setBasicAuth(properties.getUsername(), properties.getPassword() == null ? &quot;&quot; : properties.getPassword());&#10;        } else {&#10;            String msg = &quot;SonarQube credentials not configured. Set sonarqube.api-token or sonarqube.username/sonarqube.password in application properties.&quot;;&#10;            log.error(msg);&#10;            throw new IllegalStateException(msg);&#10;        }&#10;        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));&#10;        headers.setContentType(MediaType.APPLICATION_JSON);&#10;        return new HttpEntity&lt;&gt;(headers);&#10;    }&#10;&#10;    private void logRequestError(Exception e, String message) {&#10;        if (e instanceof HttpClientErrorException) {&#10;            HttpClientErrorException hce = (HttpClientErrorException) e;&#10;            String body = &quot;&quot;;&#10;            try {&#10;                body = hce.getResponseBodyAsString();&#10;            } catch (Exception ignored) {&#10;            }&#10;            log.error(&quot;{} - status: {} body: {}&quot;, message, hce.getStatusCode(), body);&#10;        } else {&#10;            log.error(&quot;{} - {}&quot;, message, e.getMessage());&#10;        }&#10;    }&#10;&#10;//    /**&#10;//     * Test connection to SonarQube&#10;//     */&#10;//    public boolean testConnection() {&#10;//        try {&#10;//            log.info(&quot;Testing SonarQube connection...&quot;);&#10;//            SonarProjectSearchResponse response = searchProjects(1);&#10;//            boolean connected = response != null;&#10;//            log.info(&quot;SonarQube connection test: {}&quot;, connected ? &quot;SUCCESS&quot; : &quot;FAILED&quot;);&#10;//            return connected;&#10;//        } catch (Exception e) {&#10;//            log.error(&quot;SonarQube connection test failed: {}&quot;, e.getMessage());&#10;//            return false;&#10;//        }&#10;//    }&#10;}" />
              <option name="updatedContent" value="package lk.sampath.leaderboard.client;&#10;&#10;import lk.sampath.leaderboard.config.SonarQubeProperties;&#10;import lk.sampath.leaderboard.dto.*;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.boot.web.client.RestTemplateBuilder;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.client.RestTemplate;&#10;import org.springframework.web.client.HttpClientErrorException;&#10;import org.springframework.web.util.UriComponentsBuilder;&#10;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class SonarQubeClient {&#10;&#10;    private final SonarQubeProperties properties;&#10;    private final RestTemplateBuilder restTemplateBuilder;&#10;&#10;    private RestTemplate restTemplate() {&#10;        // Use RestTemplateBuilder's basicAuthentication so preemptive auth is configured when supported&#10;        // If token is present, configure builder with token as username and empty password; otherwise builder stays default&#10;        if (properties.getToken() != null &amp;&amp; !properties.getToken().isBlank()) {&#10;            return restTemplateBuilder.basicAuthentication(properties.getToken(), &quot;&quot;).build();&#10;        }&#10;        if (properties.getUsername() != null &amp;&amp; !properties.getUsername().isBlank()) {&#10;            return restTemplateBuilder.basicAuthentication(properties.getUsername(), properties.getPassword() == null ? &quot;&quot; : properties.getPassword()).build();&#10;        }&#10;        return restTemplateBuilder.build();&#10;    }&#10;&#10;    public List&lt;SonarProjectSearchResponse.Component&gt; fetchAllProjects() {&#10;        List&lt;SonarProjectSearchResponse.Component&gt; allProjects = new ArrayList&lt;&gt;();&#10;        int page = 1;&#10;&#10;        while (page &lt;= properties.getMaxPages()) {&#10;            String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                    .path(&quot;/api/components/search&quot;)&#10;                    .queryParam(&quot;qualifiers&quot;, &quot;TRK&quot;)&#10;                    .queryParam(&quot;p&quot;, page)&#10;                    .queryParam(&quot;ps&quot;, properties.getPageSize())&#10;                    .toUriString();&#10;&#10;            try {&#10;                ResponseEntity&lt;SonarProjectSearchResponse&gt; response = restTemplate().exchange(&#10;                        url, HttpMethod.GET, createHttpEntity(), SonarProjectSearchResponse.class);&#10;&#10;                if (response.getBody() != null) {&#10;                    List&lt;SonarProjectSearchResponse.Component&gt; components = response.getBody().getComponents();&#10;                    if (components.isEmpty()) {&#10;                        break;&#10;                    }&#10;                    allProjects.addAll(components);&#10;&#10;                    if (components.size() &lt; properties.getPageSize()) {&#10;                        break;&#10;                    }&#10;                }&#10;                page++;&#10;            } catch (Exception e) {&#10;                logRequestError(e, &quot;Error fetching projects at page &quot; + page);&#10;                break;&#10;            }&#10;        }&#10;&#10;        log.info(&quot;Fetched {} projects from SonarQube&quot;, allProjects.size());&#10;        return allProjects;&#10;    }&#10;&#10;    public List&lt;SonarIssuesSearchResponse.IssueDetail&gt; fetchIssuesForProject(String projectKey, LocalDate fromDate, LocalDate toDate) {&#10;        List&lt;SonarIssuesSearchResponse.IssueDetail&gt; allIssues = new ArrayList&lt;&gt;();&#10;        int page = 1;&#10;&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;&#10;        while (page &lt;= properties.getMaxPages()) {&#10;            String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                    .path(&quot;/api/issues/search&quot;)&#10;                    .queryParam(&quot;componentKeys&quot;, projectKey)&#10;                    .queryParam(&quot;createdAfter&quot;, fromDate.format(formatter))&#10;                    .queryParam(&quot;createdBefore&quot;, toDate.format(formatter))&#10;                    .queryParam(&quot;p&quot;, page)&#10;                    .queryParam(&quot;ps&quot;, properties.getPageSize())&#10;                    .queryParam(&quot;additionalFields&quot;, &quot;comments&quot;)&#10;                    .toUriString();&#10;&#10;            try {&#10;                ResponseEntity&lt;SonarIssuesSearchResponse&gt; response = restTemplate().exchange(&#10;                        url, HttpMethod.GET, createHttpEntity(), SonarIssuesSearchResponse.class);&#10;&#10;                if (response.getBody() != null) {&#10;                    List&lt;SonarIssuesSearchResponse.IssueDetail&gt; issues = response.getBody().getIssues();&#10;                    if (issues.isEmpty()) {&#10;                        break;&#10;                    }&#10;                    allIssues.addAll(issues);&#10;&#10;                    if (issues.size() &lt; properties.getPageSize()) {&#10;                        break;&#10;                    }&#10;                }&#10;                page++;&#10;            } catch (Exception e) {&#10;                logRequestError(e, &quot;Error fetching issues for project &quot; + projectKey + &quot; at page &quot; + page);&#10;                break;&#10;            }&#10;        }&#10;&#10;        log.info(&quot;Fetched {} issues for project {}&quot;, allIssues.size(), projectKey);&#10;        return allIssues;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; fetchProjectMetrics(String projectKey) {&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/measures/component&quot;)&#10;                .queryParam(&quot;component&quot;, projectKey)&#10;                .queryParam(&quot;metricKeys&quot;, &quot;ncloc,bugs,vulnerabilities,code_smells&quot;)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarMeasuresResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarMeasuresResponse.class);&#10;&#10;            Map&lt;String, String&gt; metrics = new HashMap&lt;&gt;();&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getComponent() != null) {&#10;                response.getBody().getComponent().getMeasures().forEach(measure -&gt;&#10;                        metrics.put(measure.getMetric(), measure.getValue())&#10;                );&#10;            }&#10;            return metrics;&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching metrics for project &quot; + projectKey);&#10;            return Collections.emptyMap();&#10;        }&#10;    }&#10;&#10;    public Set&lt;String&gt; fetchAuthorsForProject(String projectKey) {&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/issues/authors&quot;)&#10;                .queryParam(&quot;project&quot;, projectKey)&#10;                .queryParam(&quot;ps&quot;, 500)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarAuthorsResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarAuthorsResponse.class);&#10;&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getAuthors() != null) {&#10;                return new HashSet&lt;&gt;(response.getBody().getAuthors());&#10;            }&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching authors for project &quot; + projectKey);&#10;        }&#10;        return Collections.emptySet();&#10;    }&#10;&#10;    /**&#10;     * Fetch user details (display name) from SonarQube for a given login/author key.&#10;     * Uses /api/users/search?login={login}&#10;     */&#10;    public Optional&lt;String&gt; fetchUserDisplayName(String login) {&#10;        if (login == null || login.isBlank()) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        // Use 'q' parameter which is supported by SonarQube users search API and filter results&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/users/search&quot;)&#10;                .queryParam(&quot;q&quot;, login)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarUserSearchResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarUserSearchResponse.class);&#10;&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getUsers() != null) {&#10;                // Try to find exact login match first&#10;                for (SonarUserSearchResponse.User user : response.getBody().getUsers()) {&#10;                    if (user.getLogin() != null &amp;&amp; user.getLogin().equalsIgnoreCase(login)) {&#10;                        if (user.getName() != null &amp;&amp; !user.getName().isBlank()) {&#10;                            return Optional.of(user.getName());&#10;                        }&#10;                        return Optional.of(user.getLogin());&#10;                    }&#10;                }&#10;&#10;                // If no exact login match, but there is at least one user whose name contains the login fragment, prefer that&#10;                for (SonarUserSearchResponse.User user : response.getBody().getUsers()) {&#10;                    if (user.getName() != null &amp;&amp; user.getName().toLowerCase().contains(login.toLowerCase())) {&#10;                        return Optional.of(user.getName());&#10;                    }&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching user details for login &quot; + login);&#10;        }&#10;        // No reliable display name found; return empty so caller can fall back to formatted key&#10;        return Optional.empty();&#10;    }&#10;&#10;    /**&#10;     * Fetch user details (login, name, email) from SonarQube for a given login/author key.&#10;     * Uses /api/users/search?q={login}&#10;     */&#10;    public Optional&lt;SonarUserSearchResponse.User&gt; fetchUserDetails(String login) {&#10;        if (login == null || login.isBlank()) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        String url = UriComponentsBuilder.fromUriString(properties.getBaseUrl())&#10;                .path(&quot;/api/users/search&quot;)&#10;                .queryParam(&quot;q&quot;, login)&#10;                .toUriString();&#10;&#10;        try {&#10;            ResponseEntity&lt;SonarUserSearchResponse&gt; response = restTemplate().exchange(&#10;                    url, HttpMethod.GET, createHttpEntity(), SonarUserSearchResponse.class);&#10;&#10;            if (response.getBody() != null &amp;&amp; response.getBody().getUsers() != null) {&#10;                // Log response size and first user for debugging why same name appears for many authors&#10;                log.debug(&quot;fetchUserDetails('{}') returned {} users&quot;, login, response.getBody().getUsers().size());&#10;                if (!response.getBody().getUsers().isEmpty()) {&#10;                    SonarUserSearchResponse.User first = response.getBody().getUsers().get(0);&#10;                    log.debug(&quot;First user for '{}': login='{}' name='{}' email='{}'&quot;, login, first.getLogin(), first.getName(), first.getEmail());&#10;                }&#10;                for (SonarUserSearchResponse.User user : response.getBody().getUsers()) {&#10;                    if (user.getLogin() != null &amp;&amp; user.getLogin().equalsIgnoreCase(login)) {&#10;                        return Optional.of(user);&#10;                    }&#10;                }&#10;                // Do not return a first/partial match to avoid incorrect mapping; only exact login matches are reliable&#10;                return Optional.empty();&#10;            }&#10;        } catch (Exception e) {&#10;            logRequestError(e, &quot;Error fetching user details for login &quot; + login);&#10;        }&#10;        return Optional.empty();&#10;    }&#10;&#10;    private HttpEntity&lt;?&gt; createHttpEntity() {&#10;        HttpHeaders headers = new HttpHeaders();&#10;        // Prefer API token; if not present, fall back to username/password&#10;        if (properties.getToken() != null &amp;&amp; !properties.getToken().isBlank()) {&#10;            headers.setBasicAuth(properties.getToken(), &quot;&quot;);&#10;        } else if (properties.getUsername() != null &amp;&amp; !properties.getUsername().isBlank()) {&#10;            headers.setBasicAuth(properties.getUsername(), properties.getPassword() == null ? &quot;&quot; : properties.getPassword());&#10;        } else {&#10;            String msg = &quot;SonarQube credentials not configured. Set sonarqube.api-token or sonarqube.username/sonarqube.password in application properties.&quot;;&#10;            log.error(msg);&#10;            throw new IllegalStateException(msg);&#10;        }&#10;        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));&#10;        headers.setContentType(MediaType.APPLICATION_JSON);&#10;        return new HttpEntity&lt;&gt;(headers);&#10;    }&#10;&#10;    private void logRequestError(Exception e, String message) {&#10;        if (e instanceof HttpClientErrorException) {&#10;            HttpClientErrorException hce = (HttpClientErrorException) e;&#10;            String body = &quot;&quot;;&#10;            try {&#10;                body = hce.getResponseBodyAsString();&#10;            } catch (Exception ignored) {&#10;            }&#10;            log.error(&quot;{} - status: {} body: {}&quot;, message, hce.getStatusCode(), body);&#10;        } else {&#10;            log.error(&quot;{} - {}&quot;, message, e.getMessage());&#10;        }&#10;    }&#10;&#10;//    /**&#10;//     * Test connection to SonarQube&#10;//     */&#10;//    public boolean testConnection() {&#10;//        try {&#10;//            log.info(&quot;Testing SonarQube connection...&quot;);&#10;//            SonarProjectSearchResponse response = searchProjects(1);&#10;//            boolean connected = response != null;&#10;//            log.info(&quot;SonarQube connection test: {}&quot;, connected ? &quot;SUCCESS&quot; : &quot;FAILED&quot;);&#10;//            return connected;&#10;//        } catch (Exception e) {&#10;//            log.error(&quot;SonarQube connection test failed: {}&quot;, e.getMessage());&#10;//            return false;&#10;//        }&#10;//    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>